name: Fix Remote Repository PR

on:
  workflow_dispatch:
    inputs:
      target_repo:
        description: 'Target repository (e.g., VectorInstitute/repo-name)'
        required: true
      pr_number:
        description: 'PR number to fix'
        required: true

permissions:
  contents: read
  issues: write

jobs:
  fix-pr:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout bot repository
        uses: actions/checkout@v4
        with:
          path: bot-repo

      - name: Get PR details
        id: pr-details
        run: |
          REPO="${{ github.event.inputs.target_repo }}"
          PR_NUMBER="${{ github.event.inputs.pr_number }}"

          # Get PR information
          PR_INFO=$(gh pr view $PR_NUMBER --repo "$REPO" --json \
            title,author,headRefName,headRepository,headRepositoryOwner,statusCheckRollup,baseRefName)

          echo "PR Info:"
          echo "$PR_INFO" | jq '.'

          # Extract details
          HEAD_REF=$(echo "$PR_INFO" | jq -r '.headRefName')
          BASE_REF=$(echo "$PR_INFO" | jq -r '.baseRefName')
          PR_TITLE=$(echo "$PR_INFO" | jq -r '.title')
          PR_AUTHOR=$(echo "$PR_INFO" | jq -r '.author.login')

          echo "head-ref=$HEAD_REF" >> $GITHUB_OUTPUT
          echo "base-ref=$BASE_REF" >> $GITHUB_OUTPUT
          echo "pr-title=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "pr-author=$PR_AUTHOR" >> $GITHUB_OUTPUT

          # Get failed checks
          FAILED_CHECKS=$(echo "$PR_INFO" | jq -c '[.statusCheckRollup[] | select(.conclusion == "FAILURE")]')
          echo "failed-checks=$FAILED_CHECKS" >> $GITHUB_OUTPUT

          FAILED_COUNT=$(echo "$FAILED_CHECKS" | jq 'length')
          echo "Found $FAILED_COUNT failed checks"
        env:
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}

      - name: Checkout target repository PR branch
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.inputs.target_repo }}
          ref: refs/pull/${{ github.event.inputs.pr_number }}/head
          token: ${{ secrets.ORG_ACCESS_TOKEN }}
          path: target-repo
          fetch-depth: 0

      - name: Analyze failure type
        id: analyze
        working-directory: target-repo
        run: |
          FAILED_CHECKS='${{ steps.pr-details.outputs.failed-checks }}'

          echo "Analyzing failures..."
          echo "$FAILED_CHECKS" | jq -r '.[] | "\(.name): \(.conclusion)"'

          # Categorize failures
          TEST_FAILURES=$(echo "$FAILED_CHECKS" | jq '[.[] | select(.name | test("test|spec|jest|pytest|unittest"; "i"))]')
          LINT_FAILURES=$(echo "$FAILED_CHECKS" | jq '[.[] | select(.name | test("lint|format|pre-commit|eslint|prettier|black|flake8|ruff"; "i"))]')
          SECURITY_FAILURES=$(echo "$FAILED_CHECKS" | jq '[.[] | select(.name | test("audit|security|snyk|dependabot|pip-audit"; "i"))]')
          BUILD_FAILURES=$(echo "$FAILED_CHECKS" | jq '[.[] | select(.name | test("build|compile|webpack|vite|tsc"; "i"))]')

          # Determine primary failure type
          if [ "$(echo "$TEST_FAILURES" | jq 'length')" -gt 0 ]; then
            echo "primary-type=test" >> $GITHUB_OUTPUT
          elif [ "$(echo "$LINT_FAILURES" | jq 'length')" -gt 0 ]; then
            echo "primary-type=lint" >> $GITHUB_OUTPUT
          elif [ "$(echo "$SECURITY_FAILURES" | jq 'length')" -gt 0 ]; then
            echo "primary-type=security" >> $GITHUB_OUTPUT
          elif [ "$(echo "$BUILD_FAILURES" | jq 'length')" -gt 0 ]; then
            echo "primary-type=build" >> $GITHUB_OUTPUT
          else
            echo "primary-type=unknown" >> $GITHUB_OUTPUT
          fi

          FAILED_NAMES=$(echo "$FAILED_CHECKS" | jq -r '.[].name' | paste -sd "," -)
          echo "failed-names=$FAILED_NAMES" >> $GITHUB_OUTPUT

      - name: Get failure logs
        id: get-logs
        run: |
          REPO="${{ github.event.inputs.target_repo }}"
          PR_NUMBER="${{ github.event.inputs.pr_number }}"

          # Get the most recent workflow run for the PR
          HEAD_REF="${{ steps.pr-details.outputs.head-ref }}"
          RUN_ID=$(gh run list --repo "$REPO" --branch "$HEAD_REF" --limit 5 \
            --json databaseId,status,conclusion \
            --jq '.[] | select(.conclusion == "failure") | .databaseId' | head -1)

          if [ -n "$RUN_ID" ]; then
            echo "Fetching logs for run $RUN_ID in $REPO"
            gh run view $RUN_ID --repo "$REPO" --log > /tmp/failure-logs.txt 2>&1 || echo "Could not fetch logs"

            # Truncate if too large
            if [ -f /tmp/failure-logs.txt ]; then
              tail -5000 /tmp/failure-logs.txt > /tmp/failure-logs-truncated.txt
              mv /tmp/failure-logs-truncated.txt /tmp/failure-logs.txt
            fi
          else
            echo "No failed run found" > /tmp/failure-logs.txt
          fi
        env:
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}

      - name: Load and customize prompt
        id: prepare-prompt
        run: |
          FAILURE_TYPE="${{ steps.analyze.outputs.primary-type }}"
          REPO="${{ github.event.inputs.target_repo }}"
          PR_NUMBER="${{ github.event.inputs.pr_number }}"
          PR_TITLE="${{ steps.pr-details.outputs.pr-title }}"
          PR_AUTHOR="${{ steps.pr-details.outputs.pr-author }}"
          FAILED_NAMES="${{ steps.analyze.outputs.failed-names }}"

          # Select appropriate prompt template
          case "$FAILURE_TYPE" in
            test) PROMPT_FILE="bot-repo/.github/prompts/fix-test-failures.md" ;;
            lint) PROMPT_FILE="bot-repo/.github/prompts/fix-lint-failures.md" ;;
            security) PROMPT_FILE="bot-repo/.github/prompts/fix-security-audit.md" ;;
            build) PROMPT_FILE="bot-repo/.github/prompts/fix-build-failures.md" ;;
            *) PROMPT_FILE="bot-repo/.github/prompts/fix-test-failures.md" ;;
          esac

          if [ -f "$PROMPT_FILE" ]; then
            PROMPT_CONTENT=$(cat "$PROMPT_FILE")
          else
            PROMPT_CONTENT="Fix the failing checks in this PR."
          fi

          # Replace placeholders
          PROMPT_CONTENT="${PROMPT_CONTENT//\{\{REPO_NAME\}\}/$REPO}"
          PROMPT_CONTENT="${PROMPT_CONTENT//\{\{PR_NUMBER\}\}/$PR_NUMBER}"
          PROMPT_CONTENT="${PROMPT_CONTENT//\{\{PR_TITLE\}\}/$PR_TITLE}"
          PROMPT_CONTENT="${PROMPT_CONTENT//\{\{PR_AUTHOR\}\}/$PR_AUTHOR}"
          PROMPT_CONTENT="${PROMPT_CONTENT//\{\{FAILED_CHECK_NAME\}\}/$FAILED_NAMES}"

          # Add failure logs
          if [ -f /tmp/failure-logs.txt ]; then
            LOGS_CONTENT=$(cat /tmp/failure-logs.txt)
            PROMPT_CONTENT="${PROMPT_CONTENT//\{\{FAILURE_DETAILS\}\}/$LOGS_CONTENT}"
          fi

          # Save final prompt
          echo "$PROMPT_CONTENT" > /tmp/gemini-prompt.txt
          echo "Prompt prepared for $FAILURE_TYPE failures"

      - name: Comment on PR - Starting fix
        run: |
          REPO="${{ github.event.inputs.target_repo }}"
          PR_NUMBER="${{ github.event.inputs.pr_number }}"
          FAILED_NAMES="${{ steps.analyze.outputs.failed-names }}"

          cat > /tmp/pr-comment.txt <<EOF
          ðŸ”§ Analyzing and fixing: ${FAILED_NAMES}...

          ðŸ¤– *AI Engineering Maintenance Bot*
          EOF

          gh pr comment $PR_NUMBER --repo "$REPO" --body-file /tmp/pr-comment.txt
        env:
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}

      - name: Install Claude Code CLI
        run: |
          curl -fsSL https://claude.ai/install.sh | bash
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Setup Python for Agent SDK
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Claude Agent SDK
        run: |
          pip install claude-agent-sdk

      - name: Apply AI fixes using Claude Agent SDK
        id: claude-fix
        working-directory: target-repo
        run: |
          cat > /tmp/fix_with_agent.py << 'PYTHON_SCRIPT_EOF'
          import asyncio
          import os
          import sys
          from claude_agent_sdk import query, ClaudeAgentOptions

          async def main():
              # Read the prepared prompt
              with open('/tmp/gemini-prompt.txt', 'r') as f:
                  prompt_content = f.read()

              prompt = f"""{prompt_content}

          ## Your Task
          Analyze the failures and fix the code directly. Make minimal, targeted changes to resolve the issues.

          Important:
          - Read all relevant files first
          - Apply fixes directly to the code
          - Don't skip tests or add ignore comments
          - Follow existing code patterns
          - Make changes that will make the tests pass"""

              print("ðŸ”§ Starting automated code fixes with Claude Agent...")

              options = ClaudeAgentOptions(
                  allowed_tools=["Read", "Edit", "Bash", "Glob", "Grep"],
                  permission_mode="acceptEdits",
                  cwd=os.getcwd()
              )

              fix_summary = []

              async for message in query(prompt=prompt, options=options):
                  # Capture agent's actions for summary
                  if hasattr(message, 'content') and message.content:
                      print(f"[Agent] {message.content[:200]}")
                      if len(fix_summary) < 5:  # Keep concise
                          fix_summary.append(str(message.content)[:100])

              # Save summary for PR comment
              with open('/tmp/fix-summary.txt', 'w') as f:
                  if fix_summary:
                      f.write("Applied the following fixes:\n")
                      for item in fix_summary[:3]:
                          f.write(f"- {item}\n")
                  else:
                      f.write("Analyzed the issue and applied necessary fixes.")

              print("âœ… Agent completed fixes")

          asyncio.run(main())
          PYTHON_SCRIPT_EOF

          python /tmp/fix_with_agent.py
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        continue-on-error: false

      - name: Check for changes and push
        id: push-fixes
        working-directory: target-repo
        run: |
          # Check if Agent SDK created a commit (check if HEAD differs from remote)
          git fetch origin ${{ steps.pr-details.outputs.head-ref }}

          if ! git diff --quiet HEAD FETCH_HEAD; then
            echo "âœ… Agent SDK made changes, pushing commit..."

            # Push the commit created by Agent SDK
            git push origin HEAD:${{ steps.pr-details.outputs.head-ref }}

            echo "changes-pushed=true" >> $GITHUB_OUTPUT
            echo "âœ… Fixes pushed to PR"
          elif [ -n "$(git status --porcelain)" ]; then
            echo "Uncommitted changes detected, committing..."

            git config user.name "aieng-bot-maintain[bot]"
            git config user.email "aieng-bot@vectorinstitute.ai"
            git add -A

            cat > /tmp/commit-message.txt <<EOF
          Fix ${{ steps.analyze.outputs.primary-type }} failures after dependency updates

          Automated fixes applied by AI Engineering Maintenance Bot

          Fixes: ${{ steps.analyze.outputs.failed-names }}

          Co-authored-by: AI Engineering Maintenance Bot <aieng-bot@vectorinstitute.ai>
          EOF

            git commit -F /tmp/commit-message.txt
            git push origin HEAD:${{ steps.pr-details.outputs.head-ref }}

            echo "changes-pushed=true" >> $GITHUB_OUTPUT
            echo "âœ… Fixes pushed to PR"
          else
            echo "changes-pushed=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸  No changes to push"
          fi
        env:
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}
        continue-on-error: true

      - name: Comment on PR - Result
        if: always()
        run: |
          REPO="${{ github.event.inputs.target_repo }}"
          PR_NUMBER="${{ github.event.inputs.pr_number }}"
          FAILURE_TYPE="${{ steps.analyze.outputs.primary-type }}"

          if [ "${{ steps.push-fixes.outputs.changes-pushed }}" = "true" ]; then
            # Read the fix summary if available
            FIX_SUMMARY=""
            if [ -f /tmp/fix-summary.txt ]; then
              FIX_SUMMARY=$(cat /tmp/fix-summary.txt)
            fi

            cat > /tmp/pr-result.txt <<EOF
          ðŸ”§ **Automated fix applied**

          Fixed ${FAILURE_TYPE} failures after dependency updates.

          ${FIX_SUMMARY}

          CI checks will re-run automatically.

          ðŸ¤– *AI Engineering Maintenance Bot*
          EOF
          else
            cat > /tmp/pr-result.txt <<EOF
          âš ï¸  **Unable to apply automated fix**

          Analyzed ${FAILURE_TYPE} failures but could not generate a fix automatically. Manual review may be required.

          ðŸ¤– *AI Engineering Maintenance Bot*
          EOF
          fi

          gh pr comment $PR_NUMBER --repo "$REPO" --body-file /tmp/pr-result.txt
        env:
          GH_TOKEN: ${{ secrets.ORG_ACCESS_TOKEN }}
